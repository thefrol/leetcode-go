package main

import (
	"fmt"
	"slices"
	"testing"

	"github.com/stretchr/testify/assert"
)

// https://leetcode.com/problems/increasing-triplet-subsequence/

// https://github.com/thefrol/leetcode-go

// // тут нужно найти в массиве чисел подпоследовательность номеров
// i<j<k : num(i)<num(j)<num(k)

// это задача ДП
// найти кортеж из n последовательних чисел, что
// n1<n2<n3..<nK
//
// случай 1 - len(N)>0
// случай 2 - index(Max)--index(min)>1 - и частный случай min()<Nk ( последний элемент)
// случай 3 - если случай два выполняется на отрезке (min,last]
// случай 4 - случай 3, но на отрезке (min, last] текущее число не включено
//
// Это работает в том члучае если index(Max) больше по индексу среди всех максимумов. Потому что там могут быть одинаковые
// а indexMin наоборот
// а значит максимум считаем только во втором случае

func increasingTriplet(nums []int) bool {

	// уберем дубликаты подряд
	nums = slices.Compact(nums)

	if hasSequence(nums, 3) {
		return true
	}

	min := nums[0]
	for i, v := range nums {
		if v < min && hasSequence(nums[i:], 3) {
			return true
		}
	}
	return false // или так hasSequence(nums, 3)
}

// nums[0] is minimal
func hasSequence(nums []int, count int) bool {
	switch count {
	case 0:
		return true
	case 1:
		return len(nums) >= 1
	default:
		if len(nums) < count {
			return false
		}
		indexMinFailed := -1
		for i, v := range nums {
			// проверяем i, потом ищем число мешьше i и проверяем опять
			if v > nums[0] && (indexMinFailed == -1 || v < nums[indexMinFailed]) {
				if success := hasSequence(nums[i:], count-1); success {
					return true
				} else {
					indexMinFailed = i
				}
			}

		}
	}
	return false
}

func Test(t *testing.T) {
	testCases := []struct {
		ints []int
		want bool
	}{
		// {[]int{12, 3}, false},
		// {[]int{3, 12}, false},
		// {[]int{1, 3, 4}, true},
		// {[]int{1, 1, 1, 4}, false},
		// {[]int{1, 5, 4, 4}, false}, // да уж, k не так-то просто искать будет

		// // // i не обязательно всегда минимум глобальный.
		// {[]int{6, 7, 1, 9}, true}, // даа жесть
		// {[]int{1, 5, 0, 4, 1, 3}, true},
		// {[]int{6, 7, 1, 2}, false},
		{[]int{1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 3, 7}, true},

		// но для быстрой работы можно поискать минимум
		// может как-то отсортировать числа даже
		// и постепенно отваливаться к более общему решению

		// но сначала надонаписать общее решение
	}
	for _, tC := range testCases {
		name := fmt.Sprint(tC.ints)
		t.Run(name, func(t *testing.T) {
			assert.Equal(t, tC.want, increasingTriplet(tC.ints))
		})
	}
}

// // тут нужно найти в массиве чисел подпоследовательность номеров
// // i<j<k : num(i)<num(j)<num(k)

// // думаю мы просто идём по числам.
// // 1. ищем максимум и минимум
// // 2. если нашли - сразу возвращаем
// // 3. надо ещё третье число

// // см тесты, все не так просто

// // как насчет работать по методике разделяй и властвуй. Как быстрый поиск.
// // выбераем среднее числа. И ищем слева и справа.

// // возможно для начала массив стоит отсортировать, чтобы брать числа у которых
// // вообще чисто теоретически возможны  такие значения

// // а может в процессе сортировки и как бы что-то да обнаружится лол

// // если массив очень большой, то предварительная сортировка все оч замедлит

// // мы сделаем как бы частный случай сортировки быстрым поиском.

// // V2 все хорошо, только бы быстрее она до краев доходила

// // V3 все оч просто

// func increasingTriplet(nums []int) bool {
// 	// попробую массивы не создавать
// 	// только массив проверенных чисел

// 	// ещё можем сохранять какой-то массив
// 	// есть ли у нас числа больше такого-то

// 	// тут будут граничные кейсы
// 	if len(nums) < 3 {
// 		return false
// 	}

// 	// базовый случай

// 	if len(nums) == 3 {
// 		return nums[0] < nums[1] && nums[1] < nums[2]
// 	}

// 	// основной алгоритм
// 	// если число больше предыдущего минимума,
// 	// прибавить счетчик
// 	count := 0 // количество последовательных значений, одно больше другого

// 	// главная фишка найти что-то что меньше последнего элемента
// 	// именно отсюда начинается рассчет последовательных значений
// 	// Это гарантирует, что последнее число уже, и мы ищем
// 	// ещё два последовательных с начала

// 	// в ином случае, нам надо было бы сбрасывать счетчик минимального,
// 	// и искать заново

// 	// 7,10,15,8,6(ищем отсюда)

// 	// сращу пришло решение игнорировать опускающиеся последовательности. Типа по
// 	// очереди их вырезать.
// 	// но задача вырезки довольно сложная

// 	// то есть нам надо найти длинну неубывающей подпоследовательности, >3
// 	// с вырезанием все равно не так просто

// 	//last=len(nums)-1
// 	iMin := int(Min(nums))
// 	if len(nums)-iMin < 3 {
// 		return false
// 	}

// 	// тут найдем меньшее
// 	// и в оставшемся отрезке большее, не включая первое

// 	// теперь просто ищем два числа больших, чем lessLast

// 	// Блин вот и решение задачи собсно лол
// 	// чего я там городил
// 	// жадный алгоритм, который мы ограничили
// 	mins := nums[iMin]
// 	for i := int(iMin); i < len(nums) && count < 3; i++ {
// 		if nums[i] > mins {
// 			count = count + 1
// 			mins = nums[i]
// 		}
// 	}
// 	return count >= 2
// }

// type index int

// func Min(nums []int) index {
// 	iMin := 0
// 	for i, v := range nums {
// 		if v < nums[iMin] {
// 			iMin = i
// 		}
// 	}
// 	return index(iMin)
// }
