package main

import (
	"slices"
	"testing"

	"github.com/stretchr/testify/assert"
)

// https://leetcode.com/problems/equal-row-and-column-pairs/

// https://github.com/thefrol/leetcode-go

// Нужно найти количество пар строк столбец, что значения в них совпадают

// Буду перебором работать

//  а более крутой способ - подсчитать какой-то хеш каждой строки и столбца и сравнивать!

func equalPairs(grid [][]int) int {
	n := len(grid)
	cols := make(map[int][][]int, n) // тут будет хеш по столбцам, а хеш по строкам будем в моенте считать
	// в ключе у нас сумма
	// а в значении собсно сами числа, чтобы мы могли потом проверить
	//
	// потом пришлось добавить массив массивов в значение, ибо столбца может быть два
	// а если мы посчитаем его, как один, то потом ошибемся в оценке
	// пусть у нас два столбца одинаковые. Мы когда будем идти и сравнивать значения
	// нам нужно по каждой сумме знать сколько столбцов имеют такую сумму

	for i := 0; i < n; i++ {
		sum := 0
		col := make([]int, n) // лучше сразу создам все n чисел и будем писать в них, аппенд слишком долгий
		for j := 0; j < n; j++ {
			col[j] = grid[j][i]
			sum += col[j]
		}

		cols[sum] = append(cols[sum], col)
	} // для каждой строки ищем столбец

	// а теперь найдем для каждой строки такой стольбец
	// что суммы элементов в нем совпадают
	// и если да, то проверим совпадают ли элементы
	count := 0
	for _, row := range grid {
		// если есть элемент с такой же суммой

		if cs, found := cols[Sum(row...)]; found {
			// вот о чем я говорил, при совпадении столбцов надо стриггерить оба раза инкремент счетчика
			for _, col := range cs {

				//осталось сравнить два слайса. Несмотря на то, что их хеши совпадают, сами они могут и не совпасть
				if slices.Equal(col, row) {
					count++
				}

			}
		}
	}
	return count
}

func Sum(ints ...int) int {
	// тупо сумма
	sum := 0
	for _, v := range ints {
		sum += v
	}
	return sum
}

func Test_equalPairs(t *testing.T) {
	tests := []struct {
		name string
		grid [][]int
		want int
	}{

		// {
		// 	name: "одиночная матрица",
		// 	grid: [][]int{
		// 		{1},
		// 	},
		// 	want: 1,
		// },
		// {
		// 	name: "литкод 1",
		// 	grid: [][]int{
		// 		{3, 2, 1},
		// 		{1, 7, 6},
		// 		{2, 7, 7},
		// 	},
		// 	want: 1,
		// },
		// {
		// 	name: "литкод 2",
		// 	grid: [][]int{
		// 		{3, 1, 2, 2},
		// 		{1, 4, 4, 5},
		// 		{2, 4, 2, 2},
		// 		{2, 4, 2, 2},
		// 	},
		// 	want: 3,
		// },
		{

			name: "литкод 3",
			grid: [][]int{
				{3, 1, 2, 2},
				{1, 4, 4, 4},
				{2, 4, 2, 2},
				{2, 5, 2, 2},
			},
			want: 3,
		},
	}
	for _, tt := range tests {

		t.Run(tt.name, func(t *testing.T) {
			assert.Equal(t, tt.want, equalPairs(tt.grid))
		})
	}
}
