package main

import (
	"container/ring"
	"fmt"
	"testing"

	"github.com/stretchr/testify/assert"
)

// https://leetcode.com/problems/dota2-senate/

// https://github.com/thefrol/leetcode-go

// Происходит голосование. Голосующий момент забанить следующего кандидата,
// или если он остался последним -провозгласить себя победителем. Есть две
// фракции: Радиант и Дайр.

// Короче тема такая, что мне кажется если соотношение Р:Д 1:2, то радиантам
// уже никак не победить. НУ или в пределах одного человека.

// Но для начала жадный алгоритм. А там можно в начале каждого цикла проверять
// некое условия быстрого окончания. Будем пользоваться кольцевой очередью
// и запоминать начало. Там даже наверное есть функция, которая пробегает по
// очереди и что-то там меняет, считает.

// короче мы идем по очереди. Текущий сенатор банит противоположную франкцию,
// И так пока не, окажется ноль противников - тогда объявляем победу

// даже так, если радиантов больше чем дайров, то понятно что радианты победят.
// возьмем такое условие. 3Р, 2Д.
//
// Сначала радианты хотят первыми
// РРРДД - победа в первом ходе

// Тепреь по другому их расставим
// ДДРРР
// ДДррР
// дДррр - дай р победил, хммм

// если четыре радианта
// ДДРРРР
// ДДррРР, ддррРР - победили радиант

// короче условие победы - одной фракции в два раза больше.
// то есть мы голосуем по кругу, и пока один не побеждает.

// У меня есть мнение, что одного раунда голосования всегда будет
// достаточно, чтобы определить победителя. Не представляю как это
// математически можно доказать, но мне кажется это так.

// А вообще знаю!
// Если дайров больше чем в два раза, то они победили.
// Соотношение 1 < N(Победители)/(проигравшие) < 2
// в течение раунда победители забанят... а вообще мы не знаем...

// Да в целом нам и не важно. Просто надо писатьтак цикл, чтобы
// как можно раньше срабатывал выход. То есть, мы когда наполним
// кольцевую очередь мы посчитаем количество Радиантов и Дайр,
// а потом если кого-то лишаем права голова, то будем удалять постепенно
// И на каждой итерации если кого-то удаляем, вычитать из
// счетчика по фракциям.

// Теперь как мы баним. У нас есть указатель на текущего человека
// и банящий указатель. Банящий указатель бежит вперед, пока не находит
// противоположную фракцию. Потом переход хода. Если следующий участник:
// противоположной фракции, то указатель обнуляется и начинается поиск
// и голосующего.

// А можно сделать два указателя. Один поиск следующего радианта, другой
// поиска следующего дайра.

// Мы можем даже ещё оптимизировать. Типа в первом раунду вести и подсчет
// состава сената по фракциям, и уже банить. zhestko, kanesh.

// Давай для начала что-то простое напишем.
// например два указателя. Но где очередь тогда в чем прикол очереди тут?)

// время переходить к тестам

func predictPartyVictory(senate string) string {
	sen := ring.New(len(senate))
	rcount, dcount := 0, 0
	bb := []byte(senate)

	// в нулевой итерации мы заполняем очередь и заодно считаем
	// количество сенаторов
	i := sen
	for _, c := range bb {
		i.Value = c

		// подсчитаем количество сенаторов
		switch c {
		case 'R':
			rcount++
		default:
			dcount++
		}
		i = i.Next()
	}

	// основной этап:
	// сначала проверяем количество сенаторов,
	// если одних в два раза больше чем других - объявить победу,
	// иначе: провести раунд банов.
	i = sen
	for {

		// баны
		// мы не можем воспользоваться ring.Do,
		// потому что одновременно и меняем цикл и идем по нему
		// поэтому проитерируем по кольцу
		{
			// тут где-то можно проверять, что если следующий голосущий
			// той же фракции, то начинаем поиск оппонента по тому же указаелю)
			ban := i
			for {
				// поиск победителя
				if dcount == 0 || rcount/dcount >= 2 {
					return "Radiant"
				}
				if rcount == 0 || dcount/rcount >= 2 {
					return "Dire"
				}

				ban = ban.Next()
				if i.Value != ban.Value {
					// разные фракцие - удаляем следующего
					// надо обратить внимание, что если он был первым,
					// то у нас новый первый)

					del := ban.Prev().Unlink(1) // удаляем себя
					if del.Value.(byte) == 'R' {
						rcount--
					} else {
						dcount--
					}
					break
				}
			}
		}

		i = i.Next() // переход хода
	}
}

func Test_predictPartyVictory(t *testing.T) {

	tests := []struct {
		senate, want string
	}{
		{"RD", "Radiant"},
		{"RDD", "Dire"},
		{"RDRDRDDD", "Dire"},
		{"RDRDRDDDD", "Dire"},

		// leetcode cases
		{"DR", "Dire"},
		{"DRRDRDRDRDDRDRDR", "Radiant"},
	}
	for _, tt := range tests {
		name := fmt.Sprintf("%s->%s", tt.senate, tt.want)
		t.Run(name, func(t *testing.T) {
			assert.Equal(t, tt.want, predictPartyVictory(tt.senate))
		})
	}
}
